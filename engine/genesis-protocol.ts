/**
 * Genesis Protocol (Section 3.2)
 * 
 * The Constitution & Template Generator
 * 
 * Philosophy: "The system never 'just starts.' It establishes Global Constraints first."
 * 
 * Three-Step Process:
 * - Step A: Library Scan - Query "Golden Seed" Vector DB for pre-validated templates
 * - Step B: Genesis Fallback (Magic Mode) - Spawn high-reasoning Genesis Agent if NO template found
 * - Step C: Conflict Check - Analyze User's Prompt vs Template for contradictions
 * 
 * @module engine/genesis-protocol
 * @version V2.99
 * 
 * █ ANCHOR 0: THE GENESIS PROTOCOL
 * 1. The Orchestrator (execute)
 * 2. Step A: Library Scan (Vector DB)
 * 3. Step B: Genesis Agent (Magic Mode)
 * 4. Step C: Conflict Check (The Lawyer)
 */

import { safeJsonParseObject, safeJsonParseArray, extractWithPreference } from '../utils/safe-json';
import { db, DBProjectStack, DBSkill } from '../db/ouroborosDB';
import { loadGoldenSeeds, querySkillsByTags, getAllProjectStacks } from '../db/seed-loader';
import { useOuroborosStore } from '../store/ouroborosStore';

/**
 * Project Mode - Domain classification for multi-domain synthesis
 */
export type ProjectMode = 
  | 'software'             // Default: Architecture specs (NO code)
  | 'scientific_research'  // Academic: Lit reviews, hypotheses (NO opinions)
  | 'legal_research'       // Legal: IRAC memos, case analysis (NO advice)
  | 'creative_writing'     // Narrative: Beat sheets, character arcs (NO prose)
  | 'general';             // Fallback

/**
 * Constitution: The Living Document generated by Genesis
 * Contains all constraints, roles, and tech stack decisions
 */
export interface Constitution {
    id: string;
    name: string;
    version: string;
    createdAt: number;

    // Core constraints
    constraints: ConstitutionConstraint[];

    // Tech stack decisions
    techStack: {
        frontend?: string[];
        backend?: string[];
        database?: string[];
        auth?: string[];
        hosting?: string[];
        other?: string[];
    };

    // Domain classification
    domain: string;
    subDomain?: string;

    // Injected skills from Golden Seeds
    injectedSkills: string[];

    // Source tracking
    source: 'template' | 'genesis_agent' | 'hybrid';
    templateId?: string;

    // Conflict resolution
    conflictResolutions?: ConflictResolution[];

    // Multi-Domain Expansion Fields (Requirements 1.2, 10.1, 10.5)
    mode: ProjectMode;                              // The detected/selected mode
    modeSource: 'auto_detected' | 'user_override'; // How mode was determined
    modeConfidence: number;                         // Confidence score (0-1)
    modeReasoning?: string;                         // Human-readable mode detection rationale
}

export interface ConstitutionConstraint {
    id: string;
    type: 'must_include' | 'must_avoid' | 'style' | 'architecture' | 'security' | 'performance';
    description: string;
    priority: 'critical' | 'high' | 'medium' | 'low';
    source: 'template' | 'user' | 'genesis_agent';
}

export interface ConflictResolution {
    conflictType: string;
    userRequirement: string;
    templateRequirement: string;
    resolution: string;
    resolvedBy: 'user_override' | 'template_priority' | 'genesis_agent';
}

export interface GenesisResult {
    success: boolean;
    constitution: Constitution | null;
    conflicts: ConflictDetection[];
    warnings: string[];
    stepAResult: StepAResult | null;
    stepBResult: StepBResult | null;
    stepCResult: StepCResult | null;
}

export interface StepAResult {
    templateFound: boolean;
    matchedTemplate?: DBProjectStack;
    matchedSkills: DBSkill[];
    matchConfidence: number;
}

export interface StepBResult {
    genesisAgentUsed: boolean;
    generatedConstitution?: Partial<Constitution>;
    generationTime: number;
}

export interface StepCResult {
    conflictsDetected: boolean;
    conflicts: ConflictDetection[];
    autoResolved: ConflictDetection[];
    requiresUserInput: ConflictDetection[];
}

export interface ConflictDetection {
    id: string;
    severity: 'critical' | 'warning' | 'info';
    type: 'tech_mismatch' | 'constraint_conflict' | 'scope_mismatch' | 'style_conflict';
    description: string;
    userValue: string;
    templateValue: string;
    suggestion: string;
    autoResolvable: boolean;
}

/**
 * Mode Detection Result
 * Contains the detected project mode and confidence score
 */
export interface ModeDetectionResult {
    mode: ProjectMode;
    confidence: number;
    reasoning: string;
    alternativeModes?: Array<{
        mode: ProjectMode;
        confidence: number;
    }>;
}

/**
 * Genesis Protocol Orchestrator
 * 
 * Implements the three-step process for establishing the Constitution
 */
export class GenesisProtocol {
    private ai: any;
    private model: string;

    constructor(ai: any, model: string) {
        this.ai = ai;
        this.model = model;
    }

    public setModel(model: string) {
        this.model = model;
    }

    /**
     * Execute the full Genesis Protocol
     * 
     * @param userPrompt - The user's raw request/goal
     * @param selectedStackId - Optional pre-selected stack ID from UI
     */
    async execute(userPrompt: string, selectedStackId?: string): Promise<GenesisResult> {
        // █ ANCHOR 0.1: The Genesis Orchestrator
        console.log('[Genesis] Starting Protocol...');

        const result: GenesisResult = {
            success: false,
            constitution: null,
            conflicts: [],
            warnings: [],
            stepAResult: null,
            stepBResult: null,
            stepCResult: null
        };

        try {
            // Ensure Golden Seeds are loaded on first boot
            await loadGoldenSeeds();

            // Detect project mode (Requirements 1.1, 1.2)
            console.log('[Genesis] Detecting project mode...');
            const modeDetection = await this.detectProjectMode(userPrompt);

            // Step A: Library Scan
            console.log('[Genesis] Step A: Library Scan...');
            result.stepAResult = await this.stepA_LibraryScan(userPrompt, modeDetection.mode, selectedStackId);

            // Step B: Genesis Fallback (if no template found)
            if (!result.stepAResult.templateFound) {
                console.log('[Genesis] Step B: Genesis Fallback (Magic Mode)...');
                result.stepBResult = await this.stepB_GenesisFallback(userPrompt, modeDetection.mode, result.stepAResult.matchedSkills);
            } else {
                result.stepBResult = { genesisAgentUsed: false, generationTime: 0 };
            }

            // Build initial constitution with detected mode
            const initialConstitution = this.buildInitialConstitution(
                userPrompt,
                result.stepAResult,
                result.stepBResult,
                modeDetection
            );

            // Step C: Conflict Check
            console.log('[Genesis] Step C: Conflict Check...');
            result.stepCResult = await this.stepC_ConflictCheck(userPrompt, initialConstitution);
            result.conflicts = result.stepCResult.conflicts;

            // Apply auto-resolutions and finalize constitution
            result.constitution = this.finalizeConstitution(
                initialConstitution,
                result.stepCResult.autoResolved
            );

            result.success = result.stepCResult.requiresUserInput.length === 0;

            if (result.stepCResult.requiresUserInput.length > 0) {
                result.warnings.push(`${result.stepCResult.requiresUserInput.length} conflicts require user resolution.`);
            }

            console.log('[Genesis] Protocol complete. Success:', result.success);
            return result;

        } catch (error: any) {
            console.error('[Genesis] Protocol failed:', error);
            result.warnings.push(`Genesis Protocol error: ${error.message}`);
            return result;
        }
    }

    /**
     * Step A: Library Scan
     * Query the "Golden Seed" Vector DB for pre-validated templates
     */
    private async stepA_LibraryScan(userPrompt: string, detectedMode: ProjectMode, selectedStackId?: string): Promise<StepAResult> {
        // █ ANCHOR 0.2: Step A - Library Scan
        const result: StepAResult = {
            templateFound: false,
            matchedSkills: [],
            matchConfidence: 0
        };

        try {
            // Golden Seeds currently contain software-first templates. Skip auto-matching for non-software modes.
            if (detectedMode !== 'software') {
                if (selectedStackId) {
                    console.log(`[Genesis:A] Ignoring selected software template for mode "${detectedMode}".`);
                } else {
                    console.log(`[Genesis:A] Skipping software template matching for mode "${detectedMode}".`);
                }
                return result;
            }

            // If user pre-selected a stack, use it directly
            if (selectedStackId) {
                const stack = await db.project_stacks.get(selectedStackId);
                if (stack) {
                    result.templateFound = true;
                    result.matchedTemplate = stack;
                    result.matchConfidence = 1.0;

                    // Load associated skills
                    for (const skillId of stack.preloadSkills) {
                        const skill = await db.skills.get(skillId);
                        if (skill) result.matchedSkills.push(skill);
                    }

                    console.log(`[Genesis:A] User-selected template: ${stack.name}`);
                    return result;
                }
            }

            // Extract keywords from user prompt for matching
            const keywords = this.extractKeywords(userPrompt);
            console.log(`[Genesis:A] Extracted keywords: ${keywords.join(', ')}`);

            // Query all stacks and find best match
            const allStacks = await getAllProjectStacks();
            let bestMatch: DBProjectStack | null = null;
            let bestScore = 0;

            for (const stack of allStacks) {
                const score = this.calculateStackMatchScore(keywords, stack);
                if (score > bestScore) {
                    bestScore = score;
                    bestMatch = stack;
                }
            }

            // V2.99: Check if Golden Seeds are enabled in settings
            const useGoldenSeeds = useOuroborosStore.getState().settings.enableGoldenSeeds;

            if (useGoldenSeeds && bestMatch && bestScore >= 0.3) {
                result.templateFound = true;
                result.matchedTemplate = bestMatch;
                result.matchConfidence = bestScore;

                // Load associated skills
                for (const skillId of bestMatch.preloadSkills) {
                    const skill = await db.skills.get(skillId);
                    if (skill) result.matchedSkills.push(skill);
                }

                console.log(`[Genesis:A] Auto-matched template: ${bestMatch.name} (Score: ${(bestScore * 100).toFixed(1)}%)`);
            } else {
                if (!useGoldenSeeds) {
                    console.log('[Genesis:A] Golden Seeds disabled in settings. Skipping template match.');
                } else {
                    console.log(`[Genesis:A] No template match (Threshold: 30%, Best: ${(bestScore * 100).toFixed(1)}%).`);
                }

                // Even without template match, try to find relevant skills
                result.matchedSkills = await querySkillsByTags(keywords, 5);
                console.log(`[Genesis:A] Found ${result.matchedSkills.length} relevant skills.`);
            }

            return result;

        } catch (error) {
            console.error('[Genesis:A] Library scan failed:', error);
            return result;
        }
    }

    /**
     * Step B: Genesis Fallback (Magic Mode)
     * Spawn high-reasoning Genesis Agent to generate custom Constitution
     */
    private async stepB_GenesisFallback(userPrompt: string, mode: ProjectMode, existingSkills: DBSkill[]): Promise<StepBResult> {
        // █ ANCHOR 0.3: Step B - Genesis Agent (Magic Mode)
        const startTime = Date.now();
        const result: StepBResult = {
            genesisAgentUsed: true,
            generationTime: 0
        };

        try {
            const skillContext = existingSkills.length > 0
                ? `\n\nAvailable Skills from Library:\n${existingSkills.map(s => `- ${s.name}: ${s.content.substring(0, 200)}...`).join('\n')}`
                : '';

            // █ ANCHOR 0.4: Soft-Strict Protocol (Think in Markdown, Commit in YAML)
            const prompt = this.buildGenesisFallbackPrompt(userPrompt, mode, skillContext);

            const response = await this.ai.models.generateContent({
                model: this.model,
                contents: prompt,
                // Removed JSON enforcement to allow Thinking Phase (Markdown)
                config: { temperature: 0.7 }
            });

            const responseText = response.text || '';
            console.log(`[Genesis:B] Raw LLM response length: ${responseText.length} chars`);

            // Use Soft-Strict extraction (YAML preferred, JSON fallback)
            const extracted = extractWithPreference<any>(responseText, 'yaml');
            const data = extracted.data;

            if (data) {
                console.log('[Genesis:B] YAML extraction successful:', JSON.stringify(data).substring(0, 200));
                result.generatedConstitution = {
                    domain: data.domain || 'General',
                    subDomain: data.subDomain,
                    techStack: mode === 'software' ? (data.techStack || {}) : {},
                    constraints: (data.constraints || []).map((c: any, i: number) => ({
                        id: c.id || `genesis_constraint_${i}`,
                        type: c.type || 'architecture',
                        description: c.description,
                        priority: c.priority || 'medium',
                        source: 'genesis_agent' as const
                    })),
                    source: 'genesis_agent'
                };
            } else {
                // FALLBACK: YAML extraction failed - try to extract domain from raw text
                console.warn('[Genesis:B] YAML extraction FAILED. Attempting regex fallback...');
                console.log('[Genesis:B] Response preview:', responseText.substring(0, 500));

                // Regex fallback: Try to find domain in the response
                const domainMatch = responseText.match(/domain[:\s]+["']?([^"'\n,}]+)/i);
                const techStackMatch = mode === 'software'
                    ? responseText.match(/(?:frontend|backend|database)[:\s]+\[?["']?([^"'\n\]]+)/gi)
                    : null;

                const fallbackDomain = domainMatch ? domainMatch[1].trim() : 'Unknown (Extraction Failed)';
                const fallbackTech: string[] = [];
                if (techStackMatch) {
                    techStackMatch.forEach(m => {
                        const val = m.split(/[:\s]+/).slice(1).join(' ').replace(/[\[\]"']/g, '').trim();
                        if (val) fallbackTech.push(val);
                    });
                }

                console.log(`[Genesis:B] Fallback extracted domain: "${fallbackDomain}", tech: [${fallbackTech.join(', ')}]`);

                result.generatedConstitution = {
                    domain: fallbackDomain,
                    techStack: mode === 'software' && fallbackTech.length > 0 ? { other: fallbackTech } : {},
                    constraints: [{
                        id: 'genesis_fallback_warning',
                        type: 'architecture' as const,
                        description: 'Constitution generated via fallback extraction. Review and refine manually.',
                        priority: 'medium' as const,
                        source: 'genesis_agent' as const
                    }],
                    source: 'genesis_agent'
                };
            }

            result.generationTime = Date.now() - startTime;
            console.log(`[Genesis:B] Constitution generated in ${result.generationTime}ms`);
            return result;

        } catch (error) {
            console.error('[Genesis:B] Genesis Agent failed:', error);
            result.generationTime = Date.now() - startTime;
            return result;
        }
    }

    private buildGenesisFallbackPrompt(userPrompt: string, mode: ProjectMode, skillContext: string): string {
        const modeDirectives: Record<ProjectMode, string> = {
            software: `
- Focus on system architecture and stack choices.
- Include concrete frontend/backend/data/auth/hosting choices when relevant.
- Add security and performance constraints for production-ready systems.`,
            scientific_research: `
- Focus on research methodology, evidence standards, and reproducibility.
- Do NOT propose software implementation stacks unless explicitly requested by the user.
- Include source-quality standards, analysis methods, and limitation handling constraints.`,
            legal_research: `
- Focus on legal research methodology, jurisdictional scope, and citation standards.
- Do NOT propose software implementation stacks unless explicitly requested by the user.
- Include constraints for citation rigor, issue framing, counterarguments, and non-advisory tone.`,
            creative_writing: `
- Focus on narrative structure, thematic coherence, and character/arc constraints.
- Do NOT propose software implementation stacks unless explicitly requested by the user.
- Include constraints around beat structure, POV consistency, and pacing.`,
            general: `
- Focus on structured analysis, objective framing, and validation criteria.
- Do NOT propose software implementation stacks unless explicitly requested by the user.
- Include constraints for clarity, assumptions, and verification steps.`
        };

        const yamlTemplates: Record<ProjectMode, string> = {
            software: `domain: "Specific software domain"
subDomain: "Optional sub-domain"
techStack:
  frontend:
    - React
    - TypeScript
  backend:
    - Node.js
    - Express
  database:
    - PostgreSQL
  auth:
    - JWT
  hosting:
    - Vercel
constraints:
  - id: constraint_1
    type: architecture # or must_include, must_avoid, security, performance
    description: "Description of constraint"
    priority: critical # or high, medium, low
architectureNotes: "Brief architecture rationale"`,
            scientific_research: `domain: "Specific research domain"
subDomain: "Optional sub-domain"
techStack: {}
constraints:
  - id: constraint_1
    type: must_include # or must_avoid, style, architecture, security, performance
    description: "Methodology and source-quality requirement"
    priority: critical
researchMethodology: "Study design, evidence standards, and analysis approach"`,
            legal_research: `domain: "Specific legal research domain"
subDomain: "Optional sub-domain"
techStack: {}
constraints:
  - id: constraint_1
    type: must_include # or must_avoid, style, architecture, security, performance
    description: "Jurisdiction and citation-standard requirement"
    priority: critical
legalFramework: "Jurisdictional scope, IRAC framing, and citation conventions"`,
            creative_writing: `domain: "Specific narrative domain"
subDomain: "Optional sub-domain"
techStack: {}
constraints:
  - id: constraint_1
    type: style # or must_include, must_avoid, architecture, security, performance
    description: "Structural storytelling requirement"
    priority: high
narrativeFramework: "Act structure, character arcs, and thematic guardrails"`,
            general: `domain: "Specific analysis domain"
subDomain: "Optional sub-domain"
techStack: {}
constraints:
  - id: constraint_1
    type: must_include # or must_avoid, style, architecture, security, performance
    description: "Objective and validation requirement"
    priority: high
analysisFramework: "Scope boundaries, assumptions, and verification strategy"`
        };

        return `
You are the GENESIS AGENT - a high-reasoning AI that establishes project foundations.

PROJECT MODE:
"${mode}"

USER REQUEST:
"""
${userPrompt}
"""
${skillContext}

TASK: Generate a custom Constitution (Project Foundation) aligned to the declared project mode.

### INSTRUCTIONS

1. **THINK FIRST (Markdown):**
   - Analyze the user's request deeply.
   - Determine the specific domain classification.
   - Apply these mode directives:
${modeDirectives[mode]}

2. **COMMIT CONFIG (YAML):**
   - After your analysis, output a SINGLE YAML block with the final configuration.
   - Keep \`techStack\` empty for non-software modes unless software implementation is explicitly requested.

### OUTPUT FORMAT

Think in plain text, then output this YAML structure:

\`\`\`yaml
${yamlTemplates[mode]}
\`\`\`
`;
    }

    /**
     * Step C: Conflict Check
     * Analyze User's Prompt vs Template for contradictions
     */
    private async stepC_ConflictCheck(userPrompt: string, constitution: Partial<Constitution>): Promise<StepCResult> {
        // █ ANCHOR 0.5: Step C - Conflict Check (The Lawyer)
        const result: StepCResult = {
            conflictsDetected: false,
            conflicts: [],
            autoResolved: [],
            requiresUserInput: []
        };

        try {
            const prompt = `
You are the CONFLICT ANALYZER - you detect contradictions between user requirements and project templates.

USER REQUEST:
"""
${userPrompt}
"""

CURRENT CONSTITUTION:
"""
Domain: ${constitution.domain || 'Unknown'}
Tech Stack: ${JSON.stringify(constitution.techStack || {}, null, 2)}
Constraints: ${(constitution.constraints || []).map(c => c.description).join(', ')}
"""

TASK: Identify ANY contradictions or conflicts between what the user asked for and what the constitution provides.

### INSTRUCTIONS

1. **THINK (Markdown):**
   - Briefly explain your reasoning. Is there a genuine conflict?
   - Example: "User asked for Python, but Stack is Node.js. This is a TECH MISMATCH."

2. **COMMIT (YAML):**
   - Output an array of conflicts in YAML.
   - If no conflicts, output an empty array \`[]\`.

### OUTPUT FORMAT

\`\`\`yaml
- id: conflict_1
  severity: critical # or warning, info
  type: tech_mismatch # or constraint_conflict, scope_mismatch, style_conflict
  description: "Clear description of the conflict"
  userValue: "What user asked for"
  templateValue: "What constitution provides"
  suggestion: "How to resolve this"
  autoResolvable: true # or false
\`\`\`

IMPORTANT: Only report REAL conflicts. If there's no contradiction, output \`[]\`.
`;

            const response = await this.ai.models.generateContent({
                model: this.model,
                contents: prompt,
                // Removed JSON enforcement
                config: { temperature: 0.3 }
            });

            // Use Soft-Strict extraction (YAML preferred, JSON fallback)
            const extracted = extractWithPreference<ConflictDetection[]>(response.text || '', 'yaml', []);
            const conflicts = extracted.data || [];

            if (conflicts.length > 0) {
                result.conflictsDetected = true;
                result.conflicts = conflicts;

                // Separate auto-resolvable from user-required
                for (const conflict of result.conflicts) {
                    if (conflict.autoResolvable && conflict.severity !== 'critical') {
                        result.autoResolved.push(conflict);
                    } else {
                        result.requiresUserInput.push(conflict);
                    }
                }
            }

            console.log(`[Genesis:C] Found ${result.conflicts.length} conflicts (${result.autoResolved.length} auto-resolvable)`);
            return result;

        } catch (error) {
            console.error('[Genesis:C] Conflict check failed:', error);
            return result;
        }
    }

    /**
     * Detect Project Mode from user prompt
     * Classifies the project into one of five supported modes
     * (Requirements 1.1)
     */
    async detectProjectMode(userPrompt: string): Promise<ModeDetectionResult> {
        console.log('[Genesis] Detecting project mode...');

        try {
            const validModes: ProjectMode[] = ['software', 'scientific_research', 'legal_research', 'creative_writing', 'general'];
            const preferredModeRaw = useOuroborosStore.getState().settings.defaultProjectMode as ProjectMode | undefined;
            const preferredMode = preferredModeRaw && validModes.includes(preferredModeRaw) ? preferredModeRaw : undefined;

            const prompt = `
You are a PROJECT MODE CLASSIFIER. Analyze the user's request and classify it into ONE of these categories:

**MODES:**
1. **software** - Building applications, APIs, systems, web apps, mobile apps, backend services
2. **scientific_research** - Academic research, literature reviews, studies, experiments, data analysis
3. **legal_research** - Case analysis, legal briefs, precedent research, IRAC memos, legal documents
4. **creative_writing** - Screenplays, novels, narrative structure, story development, character arcs
5. **general** - Everything else that doesn't fit the above categories

**USER REQUEST:**
"""
${userPrompt}
"""

**USER DEFAULT MODE PREFERENCE (HINT ONLY):**
${preferredMode ? preferredMode : 'none'}

**TASK:** Classify this request into ONE mode.

**INSTRUCTIONS:**
1. **THINK (Markdown):** Briefly explain your reasoning (2-3 sentences).
2. **COMMIT (JSON):** Output a single JSON object with your classification.

**OUTPUT FORMAT:**
\`\`\`json
{
  "mode": "software",
  "confidence": 0.95,
  "reasoning": "User is asking to build a web application with React and Node.js, which is clearly software development."
}
\`\`\`

**IMPORTANT:** 
- Confidence should be 0.0 to 1.0 (0.8+ means very confident)
- Default to "software" if ambiguous
- Treat the user default mode preference as a weak prior only. Override it when prompt evidence is clear.
- Be decisive - pick the BEST fit mode
`;

            const response = await this.ai.models.generateContent({
                model: this.model,
                contents: prompt,
                config: { temperature: 0.3 }
            });

            const responseText = response.text || '';
            
            // Extract JSON from response
            const extracted = extractWithPreference<{
                mode: string;
                confidence: number;
                reasoning: string;
            }>(responseText, 'json');

            if (extracted.data) {
                const data = extracted.data;
                const mode = data.mode as ProjectMode;
                const confidence = data.confidence || 0.5;
                const reasoning = data.reasoning || 'Mode detected from user prompt';

                // Validate mode
                if (!validModes.includes(mode)) {
                    console.warn(`[Genesis] Invalid mode "${mode}" detected, defaulting to "software"`);
                    return {
                        mode: 'software',
                        confidence: 0.5,
                        reasoning: 'Invalid mode detected, defaulted to software'
                    };
                }

                console.log(`[Genesis] Mode detected: ${mode} (confidence: ${(confidence * 100).toFixed(1)}%)`);
                
                return {
                    mode,
                    confidence,
                    reasoning
                };
            } else {
                // Fallback: Default to software mode
                console.warn('[Genesis] Mode detection failed, defaulting to "software"');
                return {
                    mode: 'software',
                    confidence: 0.5,
                    reasoning: 'Mode detection failed, defaulted to software'
                };
            }

        } catch (error) {
            console.error('[Genesis] Mode detection error:', error);
            return {
                mode: 'software',
                confidence: 0.5,
                reasoning: 'Error during mode detection, defaulted to software'
            };
        }
    }

    /**
     * Build initial constitution from Step A and B results
     * (Requirements 1.2, 1.5)
     */
    private buildInitialConstitution(
        userPrompt: string,
        stepA: StepAResult,
        stepB: StepBResult,
        modeDetection: ModeDetectionResult
    ): Partial<Constitution> {
        const mode = modeDetection.mode;
        const constitution: Partial<Constitution> = {
            id: crypto.randomUUID(),
            name: 'Project Constitution',
            version: '1.0.0',
            createdAt: Date.now(),
            constraints: [],
            techStack: {},
            injectedSkills: [],
            source: 'template',
            // Set mode from detection result (Requirements 1.2, 1.5)
            mode,
            modeSource: 'auto_detected',
            modeConfidence: modeDetection.confidence,
            modeReasoning: modeDetection.reasoning
        };

        // If template found, use it as base
        if (stepA.templateFound && stepA.matchedTemplate) {
            constitution.name = `${stepA.matchedTemplate.name} Constitution`;
            if (mode === 'software') {
                constitution.techStack = { ...stepA.matchedTemplate.techStack };
            }
            constitution.templateId = stepA.matchedTemplate.id;
            constitution.source = 'template';

            // Add template constraints
            for (const constraint of stepA.matchedTemplate.constraints) {
                constitution.constraints!.push({
                    id: `template_${crypto.randomUUID().substring(0, 8)}`,
                    type: 'architecture',
                    description: constraint,
                    priority: 'high',
                    source: 'template'
                });
            }
        }

        // If Genesis Agent was used, merge its output
        if (stepB.genesisAgentUsed && stepB.generatedConstitution) {
            const gen = stepB.generatedConstitution;
            constitution.domain = gen.domain;
            constitution.subDomain = gen.subDomain;
            constitution.source = stepA.templateFound ? 'hybrid' : 'genesis_agent';

            // Merge tech stack (Genesis overrides template gaps)
            if (mode === 'software') {
                constitution.techStack = {
                    ...constitution.techStack,
                    ...gen.techStack
                };
            }

            // Add Genesis constraints
            if (gen.constraints) {
                constitution.constraints = [
                    ...constitution.constraints!,
                    ...gen.constraints
                ];
            }
        }

        if (mode !== 'software') {
            constitution.techStack = {};
        }

        // Track injected skills
        constitution.injectedSkills = stepA.matchedSkills.map(s => s.id);

        // HARD FAILSAFE: If we still have no domain, extract from user prompt
        if (!constitution.domain) {
            console.warn('[Genesis] FAILSAFE: No domain from Steps A/B. Extracting from prompt...');
            constitution.domain = this.getFallbackDomainForMode(userPrompt, mode);

            // Try to extract tech stack mentions (software mode only)
            if (mode === 'software') {
                const promptLower = userPrompt.toLowerCase();
                const techKeywords = ['react', 'vue', 'angular', 'next', 'python', 'fastapi', 'django', 'node', 'express', 'postgres', 'mongodb', 'supabase', 'firebase'];
                const foundTech: string[] = [];
                for (const tech of techKeywords) {
                    if (promptLower.includes(tech)) {
                        foundTech.push(tech.charAt(0).toUpperCase() + tech.slice(1));
                    }
                }
                if (foundTech.length > 0 && Object.keys(constitution.techStack || {}).length === 0) {
                    constitution.techStack = { other: foundTech };
                }
            }

            constitution.constraints = constitution.constraints || [];
            constitution.constraints.push({
                id: 'failsafe_warning',
                type: 'architecture',
                description: 'Constitution generated via failsafe. Genesis Agent may not have produced parseable output.',
                priority: 'medium',
                source: 'genesis_agent'
            });
        }

        return constitution;
    }

    private getFallbackDomainForMode(userPrompt: string, mode: ProjectMode): string {
        const promptLower = userPrompt.toLowerCase();

        if (mode === 'software') {
            if (promptLower.includes('prediction') || promptLower.includes('forecasting') || promptLower.includes('prophecy')) {
                return 'Predictive Analytics Platform';
            }
            if (promptLower.includes('saas') || promptLower.includes('subscription')) {
                return 'SaaS Application';
            }
            if (promptLower.includes('e-commerce') || promptLower.includes('ecommerce') || promptLower.includes('shop')) {
                return 'E-Commerce Platform';
            }
            if (promptLower.includes('analytics') || promptLower.includes('data pipeline')) {
                return 'Data Analytics System';
            }
            if (promptLower.includes('dashboard') || promptLower.includes('admin panel')) {
                return 'Dashboard/Admin Tool';
            }
            if (promptLower.includes('api') || promptLower.includes('backend')) {
                return 'Backend API Service';
            }
            if (promptLower.includes('mobile') || promptLower.includes('ios') || promptLower.includes('android')) {
                return 'Mobile Application';
            }
            if (promptLower.includes('blog') || promptLower.includes('cms') || promptLower.includes('content management')) {
                return 'Content Management System';
            }
            if (promptLower.includes('chat') || promptLower.includes('messaging') || promptLower.includes('real-time')) {
                return 'Real-time Messaging Platform';
            }
            return 'Custom Software Project';
        }

        if (mode === 'scientific_research') {
            if (promptLower.includes('consciousness')) return 'Consciousness Research Program';
            if (promptLower.includes('clinical') || promptLower.includes('trial')) return 'Clinical Research Study';
            if (promptLower.includes('neuroscience')) return 'Neuroscience Research Program';
            return 'Scientific Research Program';
        }

        if (mode === 'legal_research') {
            if (promptLower.includes('contract')) return 'Contract Law Analysis';
            if (promptLower.includes('constitutional')) return 'Constitutional Law Analysis';
            if (promptLower.includes('employment')) return 'Employment Law Analysis';
            return 'Legal Research Analysis';
        }

        if (mode === 'creative_writing') {
            if (promptLower.includes('screenplay')) return 'Screenplay Structure Project';
            if (promptLower.includes('novel')) return 'Novel Structure Project';
            if (promptLower.includes('short story')) return 'Short Story Structure Project';
            return 'Creative Writing Structure Project';
        }

        return 'General Analysis Project';
    }

    /**
     * Finalize constitution with conflict resolutions
     */
    private finalizeConstitution(
        initialConstitution: Partial<Constitution>,
        autoResolved: ConflictDetection[]
    ): Constitution {
        const constitution: Constitution = {
            id: initialConstitution.id || crypto.randomUUID(),
            name: initialConstitution.name || 'Project Constitution',
            version: initialConstitution.version || '1.0.0',
            createdAt: initialConstitution.createdAt || Date.now(),
            constraints: initialConstitution.constraints || [],
            techStack: initialConstitution.techStack || {},
            domain: initialConstitution.domain || 'General',
            subDomain: initialConstitution.subDomain,
            injectedSkills: initialConstitution.injectedSkills || [],
            source: initialConstitution.source || 'genesis_agent',
            templateId: initialConstitution.templateId,
            conflictResolutions: [],
            // Ensure mode fields are always set (Requirements 10.1, 10.5)
            mode: initialConstitution.mode || 'software',
            modeSource: initialConstitution.modeSource || 'auto_detected',
            modeConfidence: initialConstitution.modeConfidence || 0.5,
            modeReasoning: initialConstitution.modeReasoning || 'Mode inferred from user prompt'
        };

        // Apply auto-resolutions
        for (const conflict of autoResolved) {
            constitution.conflictResolutions!.push({
                conflictType: conflict.type,
                userRequirement: conflict.userValue,
                templateRequirement: conflict.templateValue,
                resolution: conflict.suggestion,
                resolvedBy: 'genesis_agent'
            });
        }

        return constitution;
    }

    /**
     * Extract keywords from user prompt for template matching
     */
    private extractKeywords(text: string): string[] {
        const techKeywords = [
            'react', 'vue', 'angular', 'svelte', 'next', 'nuxt', 'vite',
            'node', 'express', 'fastapi', 'django', 'flask', 'rails',
            'python', 'javascript', 'typescript', 'rust', 'go', 'java',
            'postgres', 'postgresql', 'mysql', 'mongodb', 'redis', 'supabase', 'firebase',
            'auth', 'authentication', 'jwt', 'oauth',
            'api', 'rest', 'graphql', 'grpc',
            'vercel', 'netlify', 'aws', 'gcp', 'azure',
            'docker', 'kubernetes', 'serverless'
        ];

        const lower = text.toLowerCase();
        return techKeywords.filter(keyword => lower.includes(keyword));
    }

    /**
     * Calculate match score between keywords and stack
     */
    private calculateStackMatchScore(keywords: string[], stack: DBProjectStack): number {
        const stackTerms: string[] = [];

        // Flatten all tech stack items
        Object.values(stack.techStack).forEach(items => {
            if (items) stackTerms.push(...items.map(s => s.toLowerCase()));
        });

        // Also check name and description
        stackTerms.push(...stack.name.toLowerCase().split(/\W+/));
        stackTerms.push(...stack.description.toLowerCase().split(/\W+/));

        if (keywords.length === 0) return 0;

        let matches = 0;
        for (const keyword of keywords) {
            if (stackTerms.some(term => term.includes(keyword) || keyword.includes(term))) {
                matches++;
            }
        }

        return matches / keywords.length;
    }
}

/**
 * Factory function
 */
export function createGenesisProtocol(ai: any, model: string): GenesisProtocol {
    return new GenesisProtocol(ai, model);
}

export default GenesisProtocol;
