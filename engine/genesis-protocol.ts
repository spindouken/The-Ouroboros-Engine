/**
 * Genesis Protocol (Section 3.2)
 * 
 * The Constitution & Template Generator
 * 
 * Philosophy: "The system never 'just starts.' It establishes Global Constraints first."
 * 
 * Three-Step Process:
 * - Step A: Library Scan - Query "Golden Seed" Vector DB for pre-validated templates
 * - Step B: Genesis Fallback (Magic Mode) - Spawn high-reasoning Genesis Agent if NO template found
 * - Step C: Conflict Check - Analyze User's Prompt vs Template for contradictions
 * 
 * @module engine/genesis-protocol
 * @version V2.99
 * 
 * █ ANCHOR 0: THE GENESIS PROTOCOL
 * 1. The Orchestrator (execute)
 * 2. Step A: Library Scan (Vector DB)
 * 3. Step B: Genesis Agent (Magic Mode)
 * 4. Step C: Conflict Check (The Lawyer)
 */

import { safeJsonParseObject, safeJsonParseArray, extractWithPreference } from '../utils/safe-json';
import { db, DBProjectStack, DBSkill } from '../db/ouroborosDB';
import { loadGoldenSeeds, querySkillsByTags, getAllProjectStacks } from '../db/seed-loader';
import { useOuroborosStore } from '../store/ouroborosStore';

/**
 * Constitution: The Living Document generated by Genesis
 * Contains all constraints, roles, and tech stack decisions
 */
export interface Constitution {
    id: string;
    name: string;
    version: string;
    createdAt: number;

    // Core constraints
    constraints: ConstitutionConstraint[];

    // Tech stack decisions
    techStack: {
        frontend?: string[];
        backend?: string[];
        database?: string[];
        auth?: string[];
        hosting?: string[];
        other?: string[];
    };

    // Domain classification
    domain: string;
    subDomain?: string;

    // Injected skills from Golden Seeds
    injectedSkills: string[];

    // Source tracking
    source: 'template' | 'genesis_agent' | 'hybrid';
    templateId?: string;

    // Conflict resolution
    conflictResolutions?: ConflictResolution[];
}

export interface ConstitutionConstraint {
    id: string;
    type: 'must_include' | 'must_avoid' | 'style' | 'architecture' | 'security' | 'performance';
    description: string;
    priority: 'critical' | 'high' | 'medium' | 'low';
    source: 'template' | 'user' | 'genesis_agent';
}

export interface ConflictResolution {
    conflictType: string;
    userRequirement: string;
    templateRequirement: string;
    resolution: string;
    resolvedBy: 'user_override' | 'template_priority' | 'genesis_agent';
}

export interface GenesisResult {
    success: boolean;
    constitution: Constitution | null;
    conflicts: ConflictDetection[];
    warnings: string[];
    stepAResult: StepAResult | null;
    stepBResult: StepBResult | null;
    stepCResult: StepCResult | null;
}

export interface StepAResult {
    templateFound: boolean;
    matchedTemplate?: DBProjectStack;
    matchedSkills: DBSkill[];
    matchConfidence: number;
}

export interface StepBResult {
    genesisAgentUsed: boolean;
    generatedConstitution?: Partial<Constitution>;
    generationTime: number;
}

export interface StepCResult {
    conflictsDetected: boolean;
    conflicts: ConflictDetection[];
    autoResolved: ConflictDetection[];
    requiresUserInput: ConflictDetection[];
}

export interface ConflictDetection {
    id: string;
    severity: 'critical' | 'warning' | 'info';
    type: 'tech_mismatch' | 'constraint_conflict' | 'scope_mismatch' | 'style_conflict';
    description: string;
    userValue: string;
    templateValue: string;
    suggestion: string;
    autoResolvable: boolean;
}

/**
 * Genesis Protocol Orchestrator
 * 
 * Implements the three-step process for establishing the Constitution
 */
export class GenesisProtocol {
    private ai: any;
    private model: string;

    constructor(ai: any, model: string) {
        this.ai = ai;
        this.model = model;
    }

    public setModel(model: string) {
        this.model = model;
    }

    /**
     * Execute the full Genesis Protocol
     * 
     * @param userPrompt - The user's raw request/goal
     * @param selectedStackId - Optional pre-selected stack ID from UI
     */
    async execute(userPrompt: string, selectedStackId?: string): Promise<GenesisResult> {
        // █ ANCHOR 0.1: The Genesis Orchestrator
        console.log('[Genesis] Starting Protocol...');

        const result: GenesisResult = {
            success: false,
            constitution: null,
            conflicts: [],
            warnings: [],
            stepAResult: null,
            stepBResult: null,
            stepCResult: null
        };

        try {
            // Ensure Golden Seeds are loaded on first boot
            await loadGoldenSeeds();

            // Step A: Library Scan
            console.log('[Genesis] Step A: Library Scan...');
            result.stepAResult = await this.stepA_LibraryScan(userPrompt, selectedStackId);

            // Step B: Genesis Fallback (if no template found)
            if (!result.stepAResult.templateFound) {
                console.log('[Genesis] Step B: Genesis Fallback (Magic Mode)...');
                result.stepBResult = await this.stepB_GenesisFallback(userPrompt, result.stepAResult.matchedSkills);
            } else {
                result.stepBResult = { genesisAgentUsed: false, generationTime: 0 };
            }

            // Build initial constitution
            const initialConstitution = this.buildInitialConstitution(
                userPrompt,
                result.stepAResult,
                result.stepBResult
            );

            // Step C: Conflict Check
            console.log('[Genesis] Step C: Conflict Check...');
            result.stepCResult = await this.stepC_ConflictCheck(userPrompt, initialConstitution);
            result.conflicts = result.stepCResult.conflicts;

            // Apply auto-resolutions and finalize constitution
            result.constitution = this.finalizeConstitution(
                initialConstitution,
                result.stepCResult.autoResolved
            );

            result.success = result.stepCResult.requiresUserInput.length === 0;

            if (result.stepCResult.requiresUserInput.length > 0) {
                result.warnings.push(`${result.stepCResult.requiresUserInput.length} conflicts require user resolution.`);
            }

            console.log('[Genesis] Protocol complete. Success:', result.success);
            return result;

        } catch (error: any) {
            console.error('[Genesis] Protocol failed:', error);
            result.warnings.push(`Genesis Protocol error: ${error.message}`);
            return result;
        }
    }

    /**
     * Step A: Library Scan
     * Query the "Golden Seed" Vector DB for pre-validated templates
     */
    private async stepA_LibraryScan(userPrompt: string, selectedStackId?: string): Promise<StepAResult> {
        // █ ANCHOR 0.2: Step A - Library Scan
        const result: StepAResult = {
            templateFound: false,
            matchedSkills: [],
            matchConfidence: 0
        };

        try {
            // If user pre-selected a stack, use it directly
            if (selectedStackId) {
                const stack = await db.project_stacks.get(selectedStackId);
                if (stack) {
                    result.templateFound = true;
                    result.matchedTemplate = stack;
                    result.matchConfidence = 1.0;

                    // Load associated skills
                    for (const skillId of stack.preloadSkills) {
                        const skill = await db.skills.get(skillId);
                        if (skill) result.matchedSkills.push(skill);
                    }

                    console.log(`[Genesis:A] User-selected template: ${stack.name}`);
                    return result;
                }
            }

            // Extract keywords from user prompt for matching
            const keywords = this.extractKeywords(userPrompt);
            console.log(`[Genesis:A] Extracted keywords: ${keywords.join(', ')}`);

            // Query all stacks and find best match
            const allStacks = await getAllProjectStacks();
            let bestMatch: DBProjectStack | null = null;
            let bestScore = 0;

            for (const stack of allStacks) {
                const score = this.calculateStackMatchScore(keywords, stack);
                if (score > bestScore) {
                    bestScore = score;
                    bestMatch = stack;
                }
            }

            // V2.99: Check if Golden Seeds are enabled in settings
            const useGoldenSeeds = useOuroborosStore.getState().settings.enableGoldenSeeds;

            if (useGoldenSeeds && bestMatch && bestScore >= 0.3) {
                result.templateFound = true;
                result.matchedTemplate = bestMatch;
                result.matchConfidence = bestScore;

                // Load associated skills
                for (const skillId of bestMatch.preloadSkills) {
                    const skill = await db.skills.get(skillId);
                    if (skill) result.matchedSkills.push(skill);
                }

                console.log(`[Genesis:A] Auto-matched template: ${bestMatch.name} (Score: ${(bestScore * 100).toFixed(1)}%)`);
            } else {
                if (!useGoldenSeeds) {
                    console.log('[Genesis:A] Golden Seeds disabled in settings. Skipping template match.');
                } else {
                    console.log(`[Genesis:A] No template match (Threshold: 30%, Best: ${(bestScore * 100).toFixed(1)}%).`);
                }

                // Even without template match, try to find relevant skills
                result.matchedSkills = await querySkillsByTags(keywords, 5);
                console.log(`[Genesis:A] Found ${result.matchedSkills.length} relevant skills.`);
            }

            return result;

        } catch (error) {
            console.error('[Genesis:A] Library scan failed:', error);
            return result;
        }
    }

    /**
     * Step B: Genesis Fallback (Magic Mode)
     * Spawn high-reasoning Genesis Agent to generate custom Constitution
     */
    private async stepB_GenesisFallback(userPrompt: string, existingSkills: DBSkill[]): Promise<StepBResult> {
        // █ ANCHOR 0.3: Step B - Genesis Agent (Magic Mode)
        const startTime = Date.now();
        const result: StepBResult = {
            genesisAgentUsed: true,
            generationTime: 0
        };

        try {
            const skillContext = existingSkills.length > 0
                ? `\n\nAvailable Skills from Library:\n${existingSkills.map(s => `- ${s.name}: ${s.content.substring(0, 200)}...`).join('\n')}`
                : '';

            // █ ANCHOR 0.4: Soft-Strict Protocol (Think in Markdown, Commit in YAML)
            const prompt = `
You are the GENESIS AGENT - a high-reasoning AI that establishes project foundations.

USER REQUEST:
"""
${userPrompt}
"""
${skillContext}

TASK: Generate a custom Constitution (Project Foundation) from scratch.

### INSTRUCTIONS

1. **THINK FIRST (Markdown):**
   - Analyze the user's request deepy.
   - Determine the specific domain (e.g., "SaaS", "Internal Tool", "E-commerce").
   - Decide on the best tech stack.
   - **CRITICAL:** Reason about CONSTRAINTS. Do not assume "Client-side only" unless explicitly requested.
   - If the user wants a "Secure" app, they likely need a Backend/Database. Don't ban it!

2. **COMMIT CONFIG (YAML):**
   - After your analysis, output a SINGLE YAML block with the final configuration.

### OUTPUT FORMAT

Think in plain text, then output this YAML structure:

\`\`\`yaml
domain: "Specific domain classification"
subDomain: "Optional sub-domain"
techStack:
  frontend:
    - React
    - TypeScript
  backend:
    - Node.js
    - Express
  database:
    - PostgreSQL
  auth:
    - JWT
  hosting:
    - Vercel
constraints:
  - id: constraint_1
    type: architecture # or must_include, must_avoid, security, performance
    description: "Description of constraint"
    priority: critical # or high, medium, low
architectureNotes: "Brief architecture rationale"
\`\`\`

IMPORTANT: Tailor the Tech Stack to the precise needs of the User Request.
   - For simple scripts/prototypes: Prioritize standard libraries and minimal dependencies.
   - For production applications: Prioritize robust, scalable frameworks.
   Be specific: Name the exact libraries/frameworks intended for use.
`;

            const response = await this.ai.models.generateContent({
                model: this.model,
                contents: prompt,
                // Removed JSON enforcement to allow Thinking Phase (Markdown)
                config: { temperature: 0.7 }
            });

            const responseText = response.text || '';
            console.log(`[Genesis:B] Raw LLM response length: ${responseText.length} chars`);

            // Use Soft-Strict extraction (YAML preferred, JSON fallback)
            const extracted = extractWithPreference<any>(responseText, 'yaml');
            const data = extracted.data;

            if (data) {
                console.log('[Genesis:B] YAML extraction successful:', JSON.stringify(data).substring(0, 200));
                result.generatedConstitution = {
                    domain: data.domain || 'General',
                    subDomain: data.subDomain,
                    techStack: data.techStack || {},
                    constraints: (data.constraints || []).map((c: any, i: number) => ({
                        id: c.id || `genesis_constraint_${i}`,
                        type: c.type || 'architecture',
                        description: c.description,
                        priority: c.priority || 'medium',
                        source: 'genesis_agent' as const
                    })),
                    source: 'genesis_agent'
                };
            } else {
                // FALLBACK: YAML extraction failed - try to extract domain from raw text
                console.warn('[Genesis:B] YAML extraction FAILED. Attempting regex fallback...');
                console.log('[Genesis:B] Response preview:', responseText.substring(0, 500));

                // Regex fallback: Try to find domain in the response
                const domainMatch = responseText.match(/domain[:\s]+["']?([^"'\n,}]+)/i);
                const techStackMatch = responseText.match(/(?:frontend|backend|database)[:\s]+\[?["']?([^"'\n\]]+)/gi);

                const fallbackDomain = domainMatch ? domainMatch[1].trim() : 'Unknown (Extraction Failed)';
                const fallbackTech: string[] = [];
                if (techStackMatch) {
                    techStackMatch.forEach(m => {
                        const val = m.split(/[:\s]+/).slice(1).join(' ').replace(/[\[\]"']/g, '').trim();
                        if (val) fallbackTech.push(val);
                    });
                }

                console.log(`[Genesis:B] Fallback extracted domain: "${fallbackDomain}", tech: [${fallbackTech.join(', ')}]`);

                result.generatedConstitution = {
                    domain: fallbackDomain,
                    techStack: fallbackTech.length > 0 ? { other: fallbackTech } : {},
                    constraints: [{
                        id: 'genesis_fallback_warning',
                        type: 'architecture' as const,
                        description: 'Constitution generated via fallback extraction. Review and refine manually.',
                        priority: 'medium' as const,
                        source: 'genesis_agent' as const
                    }],
                    source: 'genesis_agent'
                };
            }

            result.generationTime = Date.now() - startTime;
            console.log(`[Genesis:B] Constitution generated in ${result.generationTime}ms`);
            return result;

        } catch (error) {
            console.error('[Genesis:B] Genesis Agent failed:', error);
            result.generationTime = Date.now() - startTime;
            return result;
        }
    }

    /**
     * Step C: Conflict Check
     * Analyze User's Prompt vs Template for contradictions
     */
    private async stepC_ConflictCheck(userPrompt: string, constitution: Partial<Constitution>): Promise<StepCResult> {
        // █ ANCHOR 0.5: Step C - Conflict Check (The Lawyer)
        const result: StepCResult = {
            conflictsDetected: false,
            conflicts: [],
            autoResolved: [],
            requiresUserInput: []
        };

        try {
            const prompt = `
You are the CONFLICT ANALYZER - you detect contradictions between user requirements and project templates.

USER REQUEST:
"""
${userPrompt}
"""

CURRENT CONSTITUTION:
"""
Domain: ${constitution.domain || 'Unknown'}
Tech Stack: ${JSON.stringify(constitution.techStack || {}, null, 2)}
Constraints: ${(constitution.constraints || []).map(c => c.description).join(', ')}
"""

TASK: Identify ANY contradictions or conflicts between what the user asked for and what the constitution provides.

### INSTRUCTIONS

1. **THINK (Markdown):**
   - Briefly explain your reasoning. Is there a genuine conflict?
   - Example: "User asked for Python, but Stack is Node.js. This is a TECH MISMATCH."

2. **COMMIT (YAML):**
   - Output an array of conflicts in YAML.
   - If no conflicts, output an empty array \`[]\`.

### OUTPUT FORMAT

\`\`\`yaml
- id: conflict_1
  severity: critical # or warning, info
  type: tech_mismatch # or constraint_conflict, scope_mismatch, style_conflict
  description: "Clear description of the conflict"
  userValue: "What user asked for"
  templateValue: "What constitution provides"
  suggestion: "How to resolve this"
  autoResolvable: true # or false
\`\`\`

IMPORTANT: Only report REAL conflicts. If there's no contradiction, output \`[]\`.
`;

            const response = await this.ai.models.generateContent({
                model: this.model,
                contents: prompt,
                // Removed JSON enforcement
                config: { temperature: 0.3 }
            });

            // Use Soft-Strict extraction (YAML preferred, JSON fallback)
            const extracted = extractWithPreference<ConflictDetection[]>(response.text || '', 'yaml', []);
            const conflicts = extracted.data || [];

            if (conflicts.length > 0) {
                result.conflictsDetected = true;
                result.conflicts = conflicts;

                // Separate auto-resolvable from user-required
                for (const conflict of result.conflicts) {
                    if (conflict.autoResolvable && conflict.severity !== 'critical') {
                        result.autoResolved.push(conflict);
                    } else {
                        result.requiresUserInput.push(conflict);
                    }
                }
            }

            console.log(`[Genesis:C] Found ${result.conflicts.length} conflicts (${result.autoResolved.length} auto-resolvable)`);
            return result;

        } catch (error) {
            console.error('[Genesis:C] Conflict check failed:', error);
            return result;
        }
    }

    /**
     * Build initial constitution from Step A and B results
     */
    private buildInitialConstitution(
        userPrompt: string,
        stepA: StepAResult,
        stepB: StepBResult
    ): Partial<Constitution> {
        const constitution: Partial<Constitution> = {
            id: crypto.randomUUID(),
            name: 'Project Constitution',
            version: '1.0.0',
            createdAt: Date.now(),
            constraints: [],
            techStack: {},
            injectedSkills: [],
            source: 'template'
        };

        // If template found, use it as base
        if (stepA.templateFound && stepA.matchedTemplate) {
            constitution.name = `${stepA.matchedTemplate.name} Constitution`;
            constitution.techStack = { ...stepA.matchedTemplate.techStack };
            constitution.templateId = stepA.matchedTemplate.id;
            constitution.source = 'template';

            // Add template constraints
            for (const constraint of stepA.matchedTemplate.constraints) {
                constitution.constraints!.push({
                    id: `template_${crypto.randomUUID().substring(0, 8)}`,
                    type: 'architecture',
                    description: constraint,
                    priority: 'high',
                    source: 'template'
                });
            }
        }

        // If Genesis Agent was used, merge its output
        if (stepB.genesisAgentUsed && stepB.generatedConstitution) {
            const gen = stepB.generatedConstitution;
            constitution.domain = gen.domain;
            constitution.subDomain = gen.subDomain;
            constitution.source = stepA.templateFound ? 'hybrid' : 'genesis_agent';

            // Merge tech stack (Genesis overrides template gaps)
            constitution.techStack = {
                ...constitution.techStack,
                ...gen.techStack
            };

            // Add Genesis constraints
            if (gen.constraints) {
                constitution.constraints = [
                    ...constitution.constraints!,
                    ...gen.constraints
                ];
            }
        }

        // Track injected skills
        constitution.injectedSkills = stepA.matchedSkills.map(s => s.id);

        // HARD FAILSAFE: If we still have no domain, extract from user prompt
        if (!constitution.domain) {
            console.warn('[Genesis] FAILSAFE: No domain from Steps A/B. Extracting from prompt...');
            // Try to extract domain from common patterns in the prompt
            const promptLower = userPrompt.toLowerCase();

            // Priority order: Most specific keywords first
            if (promptLower.includes('prediction') || promptLower.includes('forecasting') || promptLower.includes('prophecy')) {
                constitution.domain = 'Predictive Analytics Platform';
            } else if (promptLower.includes('saas') || promptLower.includes('subscription')) {
                constitution.domain = 'SaaS Application';
            } else if (promptLower.includes('e-commerce') || promptLower.includes('ecommerce') || promptLower.includes('shop')) {
                constitution.domain = 'E-Commerce Platform';
            } else if (promptLower.includes('analytics') || promptLower.includes('data pipeline')) {
                constitution.domain = 'Data Analytics System';
            } else if (promptLower.includes('dashboard') || promptLower.includes('admin panel')) {
                constitution.domain = 'Dashboard/Admin Tool';
            } else if (promptLower.includes('api') || promptLower.includes('backend')) {
                constitution.domain = 'Backend API Service';
            } else if (promptLower.includes('mobile') || promptLower.includes('ios') || promptLower.includes('android')) {
                constitution.domain = 'Mobile Application';
            } else if (promptLower.includes('blog') || promptLower.includes('cms') || promptLower.includes('content management')) {
                constitution.domain = 'Content Management System';
            } else if (promptLower.includes('chat') || promptLower.includes('messaging') || promptLower.includes('real-time')) {
                constitution.domain = 'Real-time Messaging Platform';
            } else {
                constitution.domain = 'Custom Software Project';
            }

            // Try to extract tech stack mentions
            const techKeywords = ['react', 'vue', 'angular', 'next', 'python', 'fastapi', 'django', 'node', 'express', 'postgres', 'mongodb', 'supabase', 'firebase'];
            const foundTech: string[] = [];
            for (const tech of techKeywords) {
                if (promptLower.includes(tech)) {
                    foundTech.push(tech.charAt(0).toUpperCase() + tech.slice(1));
                }
            }
            if (foundTech.length > 0 && Object.keys(constitution.techStack || {}).length === 0) {
                constitution.techStack = { other: foundTech };
            }

            constitution.constraints = constitution.constraints || [];
            constitution.constraints.push({
                id: 'failsafe_warning',
                type: 'architecture',
                description: 'Constitution generated via failsafe. Genesis Agent may not have produced parseable output.',
                priority: 'medium',
                source: 'genesis_agent'
            });
        }

        return constitution;
    }

    /**
     * Finalize constitution with conflict resolutions
     */
    private finalizeConstitution(
        initialConstitution: Partial<Constitution>,
        autoResolved: ConflictDetection[]
    ): Constitution {
        const constitution: Constitution = {
            id: initialConstitution.id || crypto.randomUUID(),
            name: initialConstitution.name || 'Project Constitution',
            version: initialConstitution.version || '1.0.0',
            createdAt: initialConstitution.createdAt || Date.now(),
            constraints: initialConstitution.constraints || [],
            techStack: initialConstitution.techStack || {},
            domain: initialConstitution.domain || 'General',
            subDomain: initialConstitution.subDomain,
            injectedSkills: initialConstitution.injectedSkills || [],
            source: initialConstitution.source || 'genesis_agent',
            templateId: initialConstitution.templateId,
            conflictResolutions: []
        };

        // Apply auto-resolutions
        for (const conflict of autoResolved) {
            constitution.conflictResolutions!.push({
                conflictType: conflict.type,
                userRequirement: conflict.userValue,
                templateRequirement: conflict.templateValue,
                resolution: conflict.suggestion,
                resolvedBy: 'genesis_agent'
            });
        }

        return constitution;
    }

    /**
     * Extract keywords from user prompt for template matching
     */
    private extractKeywords(text: string): string[] {
        const techKeywords = [
            'react', 'vue', 'angular', 'svelte', 'next', 'nuxt', 'vite',
            'node', 'express', 'fastapi', 'django', 'flask', 'rails',
            'python', 'javascript', 'typescript', 'rust', 'go', 'java',
            'postgres', 'postgresql', 'mysql', 'mongodb', 'redis', 'supabase', 'firebase',
            'auth', 'authentication', 'jwt', 'oauth',
            'api', 'rest', 'graphql', 'grpc',
            'vercel', 'netlify', 'aws', 'gcp', 'azure',
            'docker', 'kubernetes', 'serverless'
        ];

        const lower = text.toLowerCase();
        return techKeywords.filter(keyword => lower.includes(keyword));
    }

    /**
     * Calculate match score between keywords and stack
     */
    private calculateStackMatchScore(keywords: string[], stack: DBProjectStack): number {
        const stackTerms: string[] = [];

        // Flatten all tech stack items
        Object.values(stack.techStack).forEach(items => {
            if (items) stackTerms.push(...items.map(s => s.toLowerCase()));
        });

        // Also check name and description
        stackTerms.push(...stack.name.toLowerCase().split(/\W+/));
        stackTerms.push(...stack.description.toLowerCase().split(/\W+/));

        if (keywords.length === 0) return 0;

        let matches = 0;
        for (const keyword of keywords) {
            if (stackTerms.some(term => term.includes(keyword) || keyword.includes(term))) {
                matches++;
            }
        }

        return matches / keywords.length;
    }
}

/**
 * Factory function
 */
export function createGenesisProtocol(ai: any, model: string): GenesisProtocol {
    return new GenesisProtocol(ai, model);
}

export default GenesisProtocol;
